//Современный стандарт ES67
//исправление неточностей(приводившим к ошибкам), облегчение работы с языком
//нов. возм.: промисы, нов. фоhv объяв переменных, классы итд 
//поддерживает почти все современт браузеры (-IE, но для перевода в старый
// формат языка существует Babel)

//Интерполяция
let name = "Ivan",
    age = 30,
    mail = 'ex@mail.ru';

// document.write('Пользователю ' + name + ' ' + age + ' лет. Его почта: ' + mail);
document.write(`Пользователю ${name} ${age} лет. Его почта: ${mail}`);
//ES6. косые кавычки, строка внутри без плюсов и других кавычек, доступ к перемен
//через ${} (интерполяция) и всё!


//let, const
//1Видны лишь в блоке кода, огранич фигур скоб. 2Момент создания.
//3Для каждой итерации в цикле созд своя переменная
function makeArray() {
  var items = [];
  // for(var i = 0; i < 10; i++) {
    //когда мы объявили переменную исп-в var, она созд. одна на весь цикл
    // в каждой итерации она не создается заново, как это делает let, 
    //и соответсвенно после цикла она будет равна 10
  for (let i = 0; i < 10; i++) {  
    var item = function () {
      console.log(i);
    };
    items.push(item);
  }
  return items;
}
var arr = makeArray();
arr[1]();
arr[3]();
arr[7]();


//Стрелочные функции
//Облегченный синтаксис. Но есть особенности применения

let fun = () => {
  //в скобках могут быть аргументы
  console.log(this);
};
//Особенности: 1Она анонимна, без имени, можем поместить только внутрь 
//какой-то переменной, и тогда уже вызвать. Поэтому мы не сможем
// упр-ть обраб событий, если это нам необоходимо. И не сможем запускать
//ее внутри себя(некая рекурсия)
fun(); //Вызываем через переменную. Контекст - окно...

//Другой пример
let obj = {
  number: 5,
  sayNumber: function () {
    let say = () => {
      console.log(this);
      //2у стрелочной ф-ии нет своего контекста вызова, поэтому контекст она 
      //берет у родителя и соответственно, контекстом родительской ф-ии будет
      //сам объект
    };
    say();
  }
};

obj.sayNumber();
//чаще всего "=>" ф-ии исп-ся в обраб. событ, setInterval(Timeout), AJAX

let btn = document.querySelector('button');

btn.addEventListener('click', function () {
  let show = () => {
    console.log(this);
    //получается, стрел. берет контекст у родителя, т.е. у ф-ии обработчика
    //а это и будет сам объект отбрабочкика
  };
  show();
});


//Еще возможность. Значения по умолчанию

//Это ф-я, которая либо считает умножение одного на другое, если нет
//второго аргумента, то умножает на 2. Программисты придумали хитрость
// function calcOrDouble(number, basis) {
  // basis = basis || 2;//ES5 именно вот так, если не передано значение базис

  function calcOrDouble(number, basis = 2) { //ES6. Значение по умолчанию
    //можно передавать сразу ф-ии
  console.log(number*basis);
}
calcOrDouble(3,5);
calcOrDouble(6);//всё работает


//Классы.
//JS отходит от ф-ии конструкторов и переходит к классам
//каждый объект имеет протототип, который явл объектом. Все объекты и методы
// в JS наследуют их от своего прототипа. Для использования этого, мы можем
//создавать классы и плодить от них потомков

//Геометрический пример
class Rectangle {
  constructor(height, width = 21) {
    this.height = height;
    this.width = width;
  }
  calcArea() {
    return this.height * this.width;
  }
}
const square = new Rectangle(10);
console.log(square.calcArea());
//Исп-е: пользователи, модальные окна, шаблонизция итд


//Spread-оператор, оператор разворота. Разворачивает массив и превращает
// его в набор каких-то данных.
let video = ['youtube', 'vimeo', 'rutube'],
    blogs = ['wordpress', 'livejournal', 'blogger'],
    internet = [...video, ...blogs, 'vk', 'facebook']; 
    //... - spread оператор, разворачивает наши массивы в наш большой массив

console.log(internet); //теперь интренет единый массив из всех данных, без
//отд массивово. Без Spread было бы 2 массива и 2 значения

//еще практич применение
function log(a, b, c) {
  console.log(a);
  console.log(b);
  console.log(c);
  console.log(a + b * c);
  
}
let numbers = [2, 5, 7];

log(...numbers); //разложили массив на данные




